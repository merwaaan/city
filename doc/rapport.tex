\documentclass[10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{multicol}
\usepackage{subfig}

\usepackage{tikz}
\usetikzlibrary{calc}

\usepackage[margin=1.2in]{geometry}
\setlength{\columnsep}{2pc}

\usepackage[natbib=true,style=alphabetic]{biblatex}
\addbibresource{references}

\title{TITRE}
\author{Merwan Achibet}
\date{}

\begin{document}

\maketitle

\begin{abstract}
abstract abstract abstract abstract abstract abstract abstract
xabstract abstract abstract abstract abstract abstract abstract
abstract abstract abstract abstract abstract abstract abstract
abstract abstract abstract abstract abstract abstract abstract
abstract abstract abstract abstract abstract abstract abstract
abstract abstract abstract abstract abstract abstract abstract
abstract abstract abstract abstract abstract abstract abstractdsx
abstract abstract abstract abstract abstract abstract abstract
abstract abstract abstract abstract abstract abstract abstract
abstract abstract abstract abstract abstract abstract abstract
\end{abstract}

\begin{multicols}{2}

\section{Introduction}

\section{\'Etat de l'art}

La modélisation de systèmes complexes est longtemps uniquement passée
par l'usage de méthodes mathématiques; typiquement, des systèmes
d'équations différentielles. Ces techniques permettent de décrire des
lois d'évolution et d'observer, ainsi que de prédire par
extrapolation, le comportement de phénomènes du réel. Dans le cas de
systèmes prenant en compte un vaste jeu de paramètres, cette approche
peut néanmoins se révéler délicate à employer. Plus intrinsèquement,
même si une telle modélisation est basée sur des observations ancrées
dans la réalité, il s'agit d'une représentation conceptuelle d'un
problème et aucune mimique des mécaniques sous-jacentes ne s'opère.

D'un point de vue historique, les prémices de l'informatique moderne
et d'un tout autre paradigme de modélisation sont à attribuer aux
esprits du milieu du vingtième siècle. Alan Turing introduit en 1936
la machine éponyme qui, bien que purement théorique, est capable
d'éxécuter des procédures. Cette démarche se démarque de l'approche
mathématique et semble plus humaine; on ne résout pas un problème en
utilisant des fonctions associant une quantité à un résultat, mais on
agit véritablement sur les données du problème. L'idée de base de
Turing était d'ailleurs d'assimiler le fonctionnement de sa machine au
travail d'une personne remplissant les cases d'un tableau
infini. Entraîné par cette mouvance procédurale et en réaction aux
réseaux de neurones de McCulloch et Pitts, John von Neumann introduit
le terme d'automate en 1946.

Simplement, un automate est une machine qui, à partir de données
fournies en entrées, produit des données en sortie et ce, en fonction
de règles internes prédéfinies. On choisit de se concentrer sur une
sous-catégorie d'automates, les automates finis à états, changeant
leur représentation interne selon des règles de transition. John von
Neumann et Stanislaw Ulam joignent leurs travaux pour concevoir le
premier automate cellulaire. Un automate cellulaire est un système
comprenant un ensemble d'automates finis spatialement localisés,
typiquement sous forme de grille, et interconnectés en fonction de
leur proximité. Les entrées de chaque automate correspondent alors aux
états des automates voisins et de fortes relations d'interdépendance
se dégagent de cette organisation. Le jeu de la vie de Conway en est
un exemple classique. La simplicité de ses règles, mise en contraste
avec la variété des résultats produits témoigne de la richesse des
automates cellulaires CITATION.

Les automates cellulaires ont depuis été extensivement étudiés et
servent de support à de nombreuses modélisations de phénomènes
biologiques et physiques \cite{Ganguly}. La motivation d'Ulam lors de
leur conception était d'ailleurs de modéliser la croissance de
cristaux. Ils sont aussi utilisés, entre autres, pour simuler la
dynamique de fluides \cite{Frisch1986}, la croissance de tumeurs
CITATION, les dynamiques proies-prédateurs CITATION.

Les automates cellulaires, notamment de par leur caractère spatial,
semblent particulièrement appropriés aux applications géographiques,
et plus précisément, urbaines. Paradoxalement, ils ne fûrent pas
immédiatement exploités à cet effet et c'est seulement suite à un
article de Waldo Tobler, en 1975, que le rapprochement entre les
automates cellulaires et le domaine de la géographie apparaît
clairement \cite{Tobler1975}.

Il est important de remarquer que la simplicité des règles régissant
le fonctionnement d'un automate cellulaire strict s'oppose à la
qualité de la modélisation, notamment lors de la conception de modèles
spécifiques \cite{Torrens2001}. Dans ce cas, une prise de liberté
quant aux formalisme originel est autorisée, voire nécessaire, pour
obtenir des résultats réalistes \cite{White1998}.

La première limite que le formalisme de base impose est la
discrétisation des états que chaque cellule peut adopter. Même si
cette caractéristique fait partie intégrante des particularités qui
confèrent aux automates cellulaires leur simplicité, la description de
quantités pouvant arborer un large éventail de valeurs est alors
impossible. Plus concrètement, il est aisé de catégoriser les cellules
d'un espace selon le fait, par exemple, qu'elles contiennent des
installations humaines ou non (état booléen)
\cite{Benguigui2004,Cornu} ou de façon plus sophistiquée, en fonction
de leur usage terrestre (résidentiel, commercial ou industriel
\cite{Lechner} et plus \cite{Dubos-Paillard203}). Pour

L'homogénéité d'un automate cellulaire fait partie intégrante de sa
définition de base. En mettant de côté l'état qu'elles adoptent,
toutes les cellules sont identiques en forme et en structure de
voisinage. Dans le cadre de notre problématique, cette approche est
limitante car, dans une ville, les parcelles ne sont que rarement
identiques et alignées. TESSELATION DE VORONOI / TRIANGULATION DE
DELAUNAY

De la même façon, la notion de voisinage est clairement à
redéfinir. Pour des problèmes classiques, les voisinages de von
Neumann et de Moore sont régulièrement utilisés mais la relation par
contiguité qu'ils décrivent ne convient pas à la représentation des
liens de dépendance à plus grande échelle se développant dans un
système urbain. Le positionnement d'un bâtiment résidentiel dans une
ville se base évidemment sur le voisinage direct des zones considérés
(on veut ajouter une maison dans un quartier résidentiel) mais il faut
aussi prendre en compte les alentours plus distants (la centrale
thermique se trouvant à 500 mètres du site envisagé). Une solution
possible est d'étendre les voisinages de von Neumann et de Moore tout
en conservant leur forme caractéristique CITATION. Une autre idée est
d'utiliser un automate cellulaire graphe pour représenter un
espace \cite{0'Sullivan2001}.

La problématique temporelle est à aborder. Un automate cellulaire
strict est synchrone, i.e. les changements d'état de toutes les
cellules s'effectuent simultanément. Si le choix était fait de mettre
à jour chaque état de façon asynchrone, le comportement d'un automate
cellulaire serait lourdement impacté. Par exemple, les qualités
auto-réplicatives de certaines entités du jeu de la vie ne seraient
pas garanties. Il est pourtant légitime de se questionner sur
l'interêt et la validité d'un tel choix dans une simulation
urbaine. BLABLA

EXEMPLE (POTENTIEL)

AUTRES APPROCHES (L/GEOM/VEC)

ROUTES

\end{multicols}

\begin{figure}

  \subfloat[Automate cellulaire simple]{

    \begin{tikzpicture}
      \draw[step=1,gray] (0,0) grid (3,3);

      \node at (0.5,0.5) {G};
      \node at (1.5,0.5) {H};
      \node at (2.5,0.5) {I};
      \node at (0.5,1.5) {D};
      \node at (1.5,1.5) {E};
      \node at (2.5,1.5) {F};
      \node at (0.5,2.5) {A};
      \node at (1.5,2.5) {B};
      \node at (2.5,2.5) {C};
    \end{tikzpicture}

  }

  \subfloat[Automate cellulaire graphe]{

    \begin{tikzpicture}
      \draw (0.5,0.5) node[circle,draw] (g) {G};
      \draw (1.5,0.5) node[circle,draw] (h) {H};
      \draw (2.5,0.5) node[circle,draw] (i) {I};
      \draw (0.5,1.5) node[circle,draw] (d) {D};
      \draw (1.5,1.5) node[circle,draw] (e) {E};
      \draw (2.5,1.5) node[circle,draw] (f) {F};
      \draw (0.5,2.5) node[circle,draw] (a) {A};
      \draw (1.5,2.5) node[circle,draw] (b) {B};
      \draw (2.5,2.5) node[circle,draw] (c) {C};

      \draw (a) -- (b);
      \draw (a) -- (e);
      \draw (a) -- (d);
      \draw (b) -- (c);
      \draw (b) -- (f);
      \draw (b) -- (e);
      \draw (b) -- (d);
      \draw (b) -- (f);
      \draw (c) -- (f);
      \draw (d) -- (e);
      \draw (d) -- (h);
      \draw (d) -- (g);
      \draw (e) -- (c);
      \draw (e) -- (f);
      \draw (e) -- (i);
      \draw (e) -- (h);
      \draw (e) -- (g);
      \draw (f) -- (i);
      \draw (f) -- (h);
      \draw (g) -- (h);
      \draw (h) -- (i);
    \end{tikzpicture}

  }

  \caption{}
  \label{}

\end{figure}

\printbibliography

\end{document}
