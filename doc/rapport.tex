\documentclass[10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{multicol}
\usepackage{subfig}

\usepackage{tikz}
\usetikzlibrary{calc}

\usepackage[margin=1.2in]{geometry}
\setlength{\columnsep}{2pc}

\usepackage[natbib=true,style=alphabetic]{biblatex}
\addbibresource{references}

\title{TITRE}
\author{Merwan Achibet}
\date{}

\begin{document}

\maketitle

\begin{abstract}
abstract abstract abstract abstract abstract abstract abstract
xabstract abstract abstract abstract abstract abstract abstract
abstract abstract abstract abstract abstract abstract abstract
dabstract abstract abstract abstract abstract abstract abstract
abstract abstract abstract abstract abstract abstract abstract
abstract abstract abstract abstract abstract abstract abstract
abstract abstract abstract abstract abstract abstract abstractdsx
abstract abstract abstract abstract abstract abstract abstract
abstract abstract abstract abstract abstract abstract abstract
abstract abstract abstract abstract abstract abstract abstract
\end{abstract}

\begin{multicols}{2}

\section{Introduction}

\section{\'Etat de l'art}

La modélisation de systèmes complexes est longtemps uniquement passée
par l'usage de méthodes mathématiques; typiquement, des systèmes
d'équations différentielles. Ces techniques permettent de décrire des
lois d'évolution et d'observer, ainsi que de prédire par
extrapolation, le comportement de phénomènes du réel. Dans le cas de
systèmes prenant en compte un vaste jeu de paramètres, cette approche
peut néanmoins se révéler délicate à employer. Plus intrinsèquement,
même si une telle modélisation est basée sur des observations ancrées
dans la réalité, il s'agit d'une représentation conceptuelle d'un
problème et aucune mimique des mécaniques sous-jacentes ne s'opère.

D'un point de vue historique, les prémices de l'informatique moderne
et d'un tout autre paradigme de modélisation sont à attribuer aux
esprits du milieu du vingtième siècle. Alan Turing introduit en 1936
la machine éponyme qui, bien que purement théorique, est capable
d'éxécuter des procédures DETAILS?. Cette démarche se démarque de
l'approche mathématique et semble plus humaine; on ne résout pas un
problème en utilisant des fonctions associant une quantité à un
résultat mais on agit véritablement sur les données du
problème. L'idée de base de Turing était d'ailleurs d'assimiler le
fonctionnement de sa machine au travail d'une personne remplissant les
cases d'un tableau infini. Entraîné par cette mouvance procédurale et
en réaction aux réseaux de neurones de McCulloch et Pitts, John von
Neumann introduit le terme d'automate en 1946.

Simplement, un automate est une machine qui, à partir de données
fournies en entrées, produit des données en sortie et ce, en fonction
de règles internes prédéfinies. On choisit de se concentrer sur une
sous-catégorie d'automates, les automates finis à états, changeant
leur représentation interne selon des règles de transition. John von
Neumann et Stanislaw Ulam joignent leurs travaux pour concevoir le
premier automate cellulaire. Un automate cellulaire est un système
comprenant un ensemble d'automates finis spatialement localisés,
typiquement sous forme de grille, et interconnectés en fonction de
leur proximité. Les entrées de chaque automate correspondent alors aux
états des automates voisins et de fortes relations d'interdépendance
se dégagent de cette organisation. Le jeu de la vie de Conway en est
un exemple classique. La simplicité de ses règles, mise en contraste
avec la variété des résultats produits, témoigne de la richesse des
automates cellulaires CITATION.

Les automates cellulaires ont depuis été extensivement étudiés et
servent de support à de nombreuses modélisations de phénomènes
biologiques et physiques \cite{Ganguly}. La motivation d'Ulam lors de
leur conception était d'ailleurs de modéliser la croissance de
cristaux. Ils sont aussi utilisés, entre autres, pour simuler la
dynamique de fluides \cite{Frisch1986}, la croissance de tumeurs
CITATION, les dynamiques proies-prédateurs CITATION.

Les automates cellulaires, notamment de par leur caractère spatial,
semblent particulièrement appropriés aux applications géographiques,
et plus précisément, urbaines. Ils ne fûrent paradoxalement pas
immédiatement exploités à cet effet et c'est seulement suite à un
article de Waldo Tobler, en 1975, que le rapprochement entre les
automates cellulaires et le domaine de la géographie apparaît
clairement \cite{Tobler1975}.

Il est important de remarquer que la simplicité des règles régissant
le fonctionnement d'un automate cellulaire strict s'oppose à la
qualité de la modélisation, notamment lors de la conception de modèles
spécifiques \cite{Torrens2001}. Dans ce cas, une prise de liberté
quant aux formalisme originel est autorisée, voire nécessaire, pour
obtenir des résultats réalistes \cite{White1998}.

La première limite que le formalisme de base impose est la
discrétisation des états que chaque cellule peut adopter. Même si
cette caractéristique fait partie intégrante des particularités qui
confèrent aux automates cellulaires leur simplicité, la description de
quantités pouvant arborer un large éventail de valeurs est alors
impossible. Plus concrètement, il est aisé de catégoriser les cellules
d'un espace selon le fait, par exemple, qu'elles contiennent des
installations humaines ou non (état booléen)
\cite{Benguigui2004,Cornu} ou de façon plus sophistiquée, en fonction
de leur usage terrestre (résidentiel, commercial ou industriel
\cite{Lechner} et plus \cite{Dubos-Paillard203}). Pour représenter la
densité d'un ensemble urbain, ??? utilise par exemple un automate
cellulaire de dimension trois dans lequel plus une pile de cellules
occupées est haute et plus la zone représentée est peuplée
CITATION. Plus généralement, il est utile de s'autoriser à diffuser

L'homogénéité d'un automate cellulaire fait partie intégrante de sa
définition de base. En mettant de côté l'état qu'elles adoptent,
toutes les cellules sont identiques en forme et en structure de
voisinage. Dans le cadre de notre problématique, cette approche est
limitante car, dans une ville, les parcelles ne sont que rarement
identiques et alignées. Il est donc nécessaire de les représenter par
des formes géométriques diverses. Ce postulat bouscule le formalisme
strict et l'anisotropie du système. Il faut se demander si toutes les
cellules ont le même impact sur leur environnement AIRE? DENSITE?

De la même façon, la notion de voisinage est clairement à
redéfinir. Pour des problèmes classiques, les voisinages de von
Neumann et de Moore sont régulièrement utilisés mais la relation par
contiguité qu'ils décrivent ne convient pas à la représentation des
liens de dépendance à plus grande échelle se développant dans un
système urbain. Le positionnement d'un bâtiment résidentiel dans une
ville se base évidemment sur le voisinage direct des zones considérés
(on veut ajouter une maison dans un quartier résidentiel) mais il faut
aussi prendre en compte les alentours plus distants (la centrale
thermique se trouvant à 500 mètres du site envisagé peut poser
problème). Une solution possible est d'étendre les voisinages de von
Neumann et de Moore tout en conservant leur forme caractéristique
CITATION. Une autre idée est d'utiliser un automate cellulaire graphe
pour représenter un espace \cite{0'Sullivan2001} et éventuellement de
pondérer les arêtes en fonction de la distance euclidienne séparant
deux entités.

La problématique temporelle est à aborder. Un automate cellulaire
strict est synchrone, i.e. les changements d'état de toutes les
cellules s'effectuent simultanément. Si le choix était fait de mettre
à jour chaque état de façon asynchrone, le comportement d'un automate
cellulaire serait lourdement impacté. Par exemple, les qualités
auto-réplicatives de certaines entités du jeu de la vie ne seraient
pas garanties. Il est pourtant légitime de se questionner sur la
validité d'un tel choix dans une simulation urbaine, premièrement
parce qu'un ville est un système complexe et désorganisé, deuxièmement
parce les processus qui s'y déroule sont calibrés sur différentes
échelles temporelles.

Maintenant que les limitations des automates cellulaires classiques et
les contournements autorisés sont annoncés, on peut présenter quelques
exemples de simulations urbaines. L'idée générale est d'associer un
potentiel de passage d'un état à un autre à chaque cellule de l'espace
considéré. Dans les modèles déterministes, la transition à plus haut
potentiel est appliquée tandis dans les modèles stochastiques, un
tirage aléatoire biaisée peut avoir lieu. EXEMPLES

Les automates cellulaires ne sont pas l'unique moyen de modélisation
de la croissance urbaine. Certains articles CITATION prônent l'usage
d'agents s'apparentant à des ??? immobiliers. Un tel agent peut
acheter des terres, les vendre, les développer. Les développements
indépendants de chaque agent participe à l'émergence d'une ville
???. D'autres articles s'éloignent des systèmes complexes et se basent
sur l'application de règles géométriques. Dans ces cas, l'objectif est
plutôt de générer des villes à l'apparence réaliste sans se soucier du
réalisme fonctionnel car le résultat est utilisé à des fins. On peut
citer l'exemple de BLABLA

Le sujet des routes n'a pas encore été abordé, et pourtant le réseau
viaire est une moitié capitale de notre sujet ! Bien que les automates
cellulaires soient couramment utilisés pour simuler le traffic routier
(dans leur version une dimension CITATION ou deux dimensions
CITATION). Ils sont peu applicables à la construction d'un réseau car
LONG-RANGE FORME.

AGENTS EXTENDERS CONNECTORS
HYPERSTREAMLINES

\end{multicols}

\begin{figure}

  \subfloat[Automate cellulaire simple]{

    \begin{tikzpicture}
      \draw[step=1,gray] (0,0) grid (3,3);

      \node at (0.5,0.5) {G};
      \node at (1.5,0.5) {H};
      \node at (2.5,0.5) {I};
      \node at (0.5,1.5) {D};
      \node at (1.5,1.5) {E};
      \node at (2.5,1.5) {F};
      \node at (0.5,2.5) {A};
      \node at (1.5,2.5) {B};
      \node at (2.5,2.5) {C};
    \end{tikzpicture}

  }

  \subfloat[Automate cellulaire graphe]{

    \begin{tikzpicture}
      \draw (0.5,0.5) node[circle,draw] (g) {G};
      \draw (1.5,0.5) node[circle,draw] (h) {H};
      \draw (2.5,0.5) node[circle,draw] (i) {I};
      \draw (0.5,1.5) node[circle,draw] (d) {D};
      \draw (1.5,1.5) node[circle,draw] (e) {E};
      \draw (2.5,1.5) node[circle,draw] (f) {F};
      \draw (0.5,2.5) node[circle,draw] (a) {A};
      \draw (1.5,2.5) node[circle,draw] (b) {B};
      \draw (2.5,2.5) node[circle,draw] (c) {C};

      \draw (a) -- (b);
      \draw (a) -- (e);
      \draw (a) -- (d);
      \draw (b) -- (c);
      \draw (b) -- (f);
      \draw (b) -- (e);
      \draw (b) -- (d);
      \draw (b) -- (f);
      \draw (c) -- (f);
      \draw (d) -- (e);
      \draw (d) -- (h);
      \draw (d) -- (g);
      \draw (e) -- (c);
      \draw (e) -- (f);
      \draw (e) -- (i);
      \draw (e) -- (h);
      \draw (e) -- (g);
      \draw (f) -- (i);
      \draw (f) -- (h);
      \draw (g) -- (h);
      \draw (h) -- (i);
    \end{tikzpicture}

  }

  \caption{}
  \label{}

\end{figure}

\printbibliography

\end{document}
